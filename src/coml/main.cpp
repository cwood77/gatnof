#include <cstring>
#include <fstream>
#include <iostream>
#include <list>
#include <map>
#include <sstream>
#include <vector>

class iObject {
public:
   virtual ~iObject() {}

   virtual void insert(std::ostream& o) = 0;
};

class textObject : public iObject {
public:
   virtual void insert(std::ostream& o) { o << payload; }

   std::string payload;
};

class objectTable {
public:
   ~objectTable()
   {
      for(auto it = m_objects.begin();it!=m_objects.end();++it)
         for(auto *pO : it->second)
            delete pO;
   }

   std::list<iObject*>& create(size_t i)
   {
      std::list<iObject*>& l = m_objects[i];
      if(l.size())
         throw std::runtime_error("object multiply defined?");
      return l;
   }

   std::list<iObject*>& demand(size_t i)
   {
      std::list<iObject*>& l = m_objects[i];
      if(l.size() == 0)
         throw std::runtime_error("object undefined?");
      return l;
   }

private:
   std::map<size_t,std::list<iObject*> > m_objects;
};

void eatUntil(const char*& pThumb, char c)
{
   for(;*pThumb!=c;++pThumb);
   ++pThumb;
}

void parseObject(const char*& pThumb, std::list<iObject*>& list)
{
   if(::strncmp(pThumb,"txt:",4)==0)
   {
      auto *pObj = new textObject();
      list.push_back(pObj);
      pObj->payload = pThumb + 4;
   }
   else if(::strncmp(pThumb,"ctl:",4)==0)
   {
      auto *pObj = new textObject();
      list.push_back(pObj);
   }
   else
   {
      std::stringstream stream;
      stream << "unknown object '" << pThumb << "'";
      throw std::runtime_error(stream.str());
   }
#if 0
   while(*pThumb != 0)
   {
      if(::strncmp(pThumb,"clear(",6)==0)
      {
         list.push_back(new clearObject());
         eatUntil(pThumb,')');
      }
      else if(::strncmp(pThumb,"fg(",3)==0)
      {
         auto *pObj = new fgObject();
         list.push_back(pObj);
         {
            char buffer[100];
            ::sscanf(pThumb,"fg(%[^)]",buffer);
            pObj->setColor(buffer);
         }
         eatUntil(pThumb,')');
      }
      else if(::strncmp(pThumb,"bg(",3)==0)
      {
         auto *pObj = new bgObject();
         list.push_back(pObj);
         {
            char buffer[100];
            ::sscanf(pThumb,"bg(%[^)]",buffer);
            pObj->setColor(buffer);
         }
         eatUntil(pThumb,')');
      }
      else
      {
         std::stringstream stream;
         stream << "unknown object '" << pThumb << "'";
         throw std::runtime_error(stream.str());
      }
   }
#endif
}

void parseObjectLine(const std::string& line, bool& stop, objectTable& oTable)
{
   if(stop || line.empty())
      return;
   stop = (line == "; comment");
   if(stop)
      return;

   int number = 0;
   ::sscanf(line.c_str(),"%d=",&number);
   const char *pThumb = line.c_str();
   eatUntil(pThumb,'=');

   auto& list = oTable.create(number);
   parseObject(pThumb,list);
}

int main(int argc, const char *argv[])
{
   std::cout << "{{" << std::endl;
   for(int i=0;i<argc;i++)
   {
      std::cout << "  " << argv[i] << std::endl;
   }
   std::cout << "}}" << std::endl;

   // load all the lines
   std::vector<std::string> lines;
   {
      std::ifstream in(argv[1]);
      while(in.good())
      {
         std::string line;
         std::getline(in,line);
         lines.push_back(line);
      }
   }

   // enforce ID
   if(::strncmp(lines[0].c_str(),"coml v1 ",8) != 0)
   {
      std::cerr << "bad coml header" << std::endl;
      return -1;
   }

   // read index
   int height = 0;
   ::sscanf(lines[0].c_str(),"coml v1 %d",&height);

   // compute name
   std::string name;
   {
      const char *pThumb = ::strstr(argv[1],"/screen.") + 8;
      if(!pThumb)
      {
         std::cerr << "bad coml file path" << std::endl;
         return -1;
      }
      name = std::string(pThumb,::strlen(pThumb) - 5);
   }

   // build object table
   objectTable oTable;
   for(size_t i=1+height;;i++)
   {
      if(i >= lines.size())
         break; // done
      bool stop = false;
      parseObjectLine(lines[i],stop,oTable);
      if(stop)
         break; // rest are comments
   }

   // generate
   std::ofstream out(argv[2]);
   out << "// *******************************" << std::endl;
   out << "// ** code generated by coml" << std::endl;
   out << "// *******************************" << std::endl;
   out << std::endl;
   out << "#include \"../../src/cmn/service.hpp\"" << std::endl;
   out << "#include \"../../src/cui/api.hpp\"" << std::endl;
   out << "#include \"../../src/cui/pen.hpp\"" << std::endl;
   out << "#include \"../../src/tcatlib/api.hpp\"" << std::endl;
   out << "#include <iostream>" << std::endl;
   out << std::endl;
   out << "class " << name << "_image : public cui::iImage {" << std::endl;
   out << "public:" << std::endl;
   out << "   virtual void render()" << std::endl;
   out << "   {" << std::endl;
   out << "      tcat::typePtr<cmn::serviceManager> svcMan;" << std::endl;
   out << "      auto& pn = svcMan->demand<pen::object>();" << std::endl;
   out << std::endl;
   for(int i=0;i<height;i++)
   {
      out << "      pn.str() << \"";

      auto& line = lines[i+1];
      for(size_t j=0;j!=line.length();j++)
      {
         if(::isdigit(line.c_str()[j]))
         {
            int id = 0;
            //::sscanf(line.c_str()+j,"%d",&id);
            id = (line.c_str()[j] - '0');
            auto& objs = oTable.demand(id);
            for(auto *pObj : objs)
               pObj->insert(out);
         }
         else
            out << std::string(1,line.c_str()[j]);
      }
      out << "\" << std::endl;" << std::endl;
   }
   out << "   }" << std::endl;
   out << std::endl;
   out << "   virtual cui::pnt demandPnt(const std::string& id) { throw 3.14; }" << std::endl;
   out << "};" << std::endl;
   out << std::endl;
   out << "class " << name << "_image_fac : public cui::plugInFactoryT<" << name << "_image,cui::iImage> {" << std::endl;
   out << "public:" << std::endl;
   out << "   " << name << "_image_fac() : cui::plugInFactoryT<" << name << "_image,cui::iImage>(\"" << name << "\") {}" << std::endl;
   out << "};" << std::endl;
   out << std::endl;
   out << "tcatExposeTypeAs(" << name << "_image_fac,cui::iPlugInFactory);" << std::endl;

   return 0;
}
